---
layout:     post
title:      面向快乐的程序设计-C#篇
subtitle:   快乐的，不快乐的，到最后都是我自己的。
date:       2020-7-21
author:     Elias
header-img: img/post-bg-bluewhale_moon.jpg
catalog: true
tags:

    - Blog
---

# 面向快乐的程序设计-C#篇

## 前言

当然是为了快——乐——

### C#是啥呀

- 用C#做数据库课设的前端真方便。(。・∀・)ノ

  ​																																							——2017.5.10	在做数据库课设的斯斯

- C# (英文名为 CSharp) 是微软开发的一种面向对象的编程语言，其语法与 [C++](http://c.biancheng.net/cplus/) 类似，但在编程过程中要比 C++ 简单；C#语言本身简单、安全，它比C、C++、Java提供了更多的数据类型，并且每个数据类型都是固定大小的；C#具有面向对象语言的基本特征，即封装、继承、多态；C#支持跨平台，截止至C#6.0版本，已经能够在Mac、Linux等除Windows以外的多个平台使用；C#不仅能开发在控制台下运行的应用程序，也能够开发Windows窗体应用程序、网站、手机应用等多种应用程序。

  ​																																													——2020.7.21	源自网络

- 采用C#进行窗体开发，可以快速搭建出软件UI界面框架，能在一定程度上进行人机交互。如果需要花里胡哨的UI界面，可以自行编写控件，也可以网上~~白嫖~~下载别人的控件，不过还是建议使用其他语言并在相应引擎上进行开发。

  ​																																								——2020.7.21	是阳光明媚的一天呀

> ### C#基础语法
>
> #### 		C#基本数据类型
>
> - #### 	C#运算符
>
> - #### 	C#变量
>
> - #### 	C#常量
>
> - #### 	C#变量命名规则
>
> - #### 	C# if else
>
> - #### 	C# switch case
>
> - #### 	C# for循环
>
> - #### 	C# while循环
>
> - #### 	C# do while循环
>
> - #### 	C# break
>
> - #### 	C# continue
>
> - #### 	C# goto
>
>

> ### C#类和对象
>
> ### C#字符串
>
> ### C#数组
>
> ### C#继承
>
> ### C#接口
>
> ### C#集合
>
> ### C#泛型
>
> ### C#文件操作
>

### C#委托和事件

> A给了B一个委托：“B君B君，要不你去和C妹说一下我喜欢她？”
>

- ### C#委托（Delegate）

  委托不是方法！不是方法！不是方法！

  虽然委托的定义与方法比较相似，但是委托并不能被称为方法，委托是一种引用类型。

  使用委托时需要遵循三步走：声明委托、实例化委托、调用委托。

  > “委托很负责任，只要被调用了，他就会竭尽全力把被委托的事情全部做了。”

- #### C#命名方法委托

  ```c#
  //修饰符 delegate 返回值类型 委托名(参数列表)；
  public delegate void TellMyLove();
  ```

  委托的定义和方法的定义非常相似，但是委托不是方法嗷！！！

  当委托定义好之后，我们就可以对委托进行实例化了。

  委托酱紫实例化 ↓

  ```c#
  //委托名 委托对象名 = new 委托名(方法名);
  TellMyLove B = new TellMyLove(TalkToC);
  ```

  在委托时应用的方法可能是静态方法(static)或是实例方法，对于这两种情况，需要带入的方法名有所不同。现在大家都是B了，下面各位B们将在这两种情况下，帮助A告诉C：“A喜欢C”。

  - 委托中传入静态方法

    ```c#
    class Program
    {
    	public delegate void TellMyLove();
    	static void Main(String[] args)
        {
    		TellMyLove B = new TellMyLove(Talk.WhatAWantToSay);
    		B();//到你行动了！
    	}
    }
    class Talk
    {
        public static void WhatAWantToSay()
        {
            MessageBox.Show("Hey, C, A said he love you.");
        }
    }
    ```

    在静态方法中，向委托传递方法名时只需要使用“`类名.方法名`”的形式。

  - 委托中传入实例方法

    ```c#
    class Program
    {
        public delegate void TellMyLove();
        static void Main(String[] args)
        {
            TellMyLove B = new TellMyLove(new Talk().WhatAWantToSay);
            B();//行动吧！
        }
    }
    class Talk
    {
        public void WhatAWantToSay()
        {
            MessageBox.Show("Hey, C, A said he really love you.");
        }
    }
    ```

    这里在委托中使用的是实例方法，因此需要通过类的实例来调用方法，即需要使用“`new 类名().方法名`”的形式。

- #### C#多播委托

  多播委托就是指在一个委托中注册多个方法，在注册方法的时候可以通过使用“+”（或者“-”）来实现添加（或者撤销）方法。

  也就是说A君除了可以委托B君告诉C妹他喜欢C妹以外，还可以委托B君帮忙约个时间啥的。也就是说一个委托里可以包含多件事情。

  > “诶诶，B君，你看到C妹的时候告诉她我喜欢她，然后把这束玫瑰花🌹也送给她！谢谢！”

  下面除了委托B君告诉C妹A君喜欢她之外，还希望B君帮A君把玫瑰花送给C妹。

  ```c#
  class Program
      {
          public delegate void TellMyLove();
          static void Main(String[] args)
          {
              //把这个委托需求交给B了！（实例化委托）
              TellMyLove B = new TellMyLove(new Talk().WhatAWantToSay);
  
              //还希望B能够帮A送一朵花，因此需要向这个委托注册方法
              B += new Talk().SendFlower;
  
              B();//行动吧！
          }
      }
      class Talk
      {
          public void WhatAWantToSay()
          {
              MessageBox.Show("\"Hey, C, A said he really love you.\"");
          }
          public void SendFlower()
          {
              MessageBox.Show("Send a flower to C");
          }
      }
  ```

  如果A君得知C妹花粉过敏，在B君开始完成这个委托之前，A君还可以撤销委托中注册的这个送花的方法，即在委托注册方法时使用`-=`操作就可以了。

- #### C#匿名委托

  匿名委托实际上就是在委托中通过定义代码块来实现委托的作用。匿名委托的语法形式如下。

  ```c#
  //1.定义委托
  修饰符 delegate 返回值类型 委托名(参数列表);
  ```

  ```c#
  //2.定义匿名委托
  委托名 委托对象 = delegate
  {
      //代码块	/该委托想要做的事情
  };	//←细节标点嗷
  ```

  ```c#
  //3.调用匿名委托
  委托对象名(参数列表);
  ```

  现在我们通过匿名委托的方式，让B君再帮A君对C妹进行一次表白，这次我们仍然需要告诉C妹A君喜欢她，并送她一朵花。

  > "表白的形式各不同相同，但其本质都是一次勇敢的尝试。"

  ```c#
  public delegate void TellMyLove();
      class Program
      {
          public delegate void TellMyLove();
          static void Main(String[] args)
          {
              //不用注册方法了，直接在实例化委托的时候实现具体操作
              TellMyLove B = delegate
              {
                  MessageBox.Show("\"Ms.C, Mr.A said he love you!\"");
                  MessageBox.Show("Mr.B send a flower to Ms.C");
              };
  
              //要做的事情都写委托里了，上吧，B君！
              B();
          }
      }
  ```

  

- ### C#事件

  > 事件是一种引用类型，实际上也是一种特殊的委托。

  每一个事件的发生都会有一个发送方和接收方，发送方是指引发事件的对象，接收方则是获取、处理事件。事件需要与委托一起使用。

  > A君对B君说：“诶诶，B君，**当你看到C妹后**，你和她说我喜欢她呗。”

  事件定义的语法形式如下：

  ```c#
  访问修饰符 event 委托名 事件名;
  ```

  在定义事件时会使用到委托，因此需要在定义事件之前定义委托。

  定义事件之后需要定义事件所使用的方法，并通过事件来调用委托。

  现在我们需要在B君碰到C妹这个事件发生时，才让B君帮A君传递告白信息。

  ```c#
  class Program
      {
          //定义委托
          //我们把这个委托给B
          public delegate void B();
          //定义事件
          //当B遇到C
          public event B MeetC;
          //定义委托中调用的方法（定义需要委托的事）
          //B的委托内容就是帮助A君告白
          public void TellALove()
          {
              MessageBox.Show("\"Hey, Ms.C, Mr.A said he love you\"");
          }
          //创建触发事件的方法
          //触发B去执行他的委托的这样一个事件
          public void WhenMeetC()
          {
              //触发事件,必须与事件是同名方法
              MeetC();
          }
                  
          static void Main(String[] args)
          {
              //创建该类实例
              Program program = new Program();
              //实例化事件，使用委托指向处理方法
              program.MeetC = new B(program.TellALove);
              //调用触发事件的方法
              program.WhenMeetC();
          }
      }
  ```

  > “诶诶，B君，你再帮我把这束花给C妹吧！”

  按照之前的老规矩，这次我们需要B君告诉A君喜欢C妹的同时，还需要B君帮忙送一朵花。

  ```c#
  class Program
      {
         static void Main()
          {
              //创建TellALove类的实例
              TellALove tellALove = new TellALove();
              //实例化TellALove类中的事件，使用委托指向处理方法
              //把需要B做的事情绑到B遇到C这个事件上
              tellALove.MeetCEvent += new TellALove.B(TellALove.TalkToC);
              tellALove.MeetCEvent += new TellALove.B(TellALove.SendFlowerToC);
              //调用触发事件的方法
              //现在让B去学校吧,他会在学校碰到C
              tellALove.BGoToSchool();
          }
      }
  
      class TellALove
      {
          //定义委托
          //我们把委托给B君
          public delegate void B();
          //定义事件
          //我们把 B君遇到C妹 称为一个事件
          public event B MeetCEvent;
          //定义委托中使用的方法
          //写下B具体需要做的一些事情
          public static void TalkToC()
          {
              MessageBox.Show("\"Hey, Ms.C, Mr.A said he love you\"");
          }
          public static void SendFlowerToC()
          {
              MessageBox.Show("B send a flower to C");
          }
          //创建触发事件的方法
          //写下B遇到C的方法，比如B去学校了，那么B可以在学校里碰到C
          public void BGoToSchool()
          {
              MeetCEvent();
          }
      }
  ```

  需要注意的是，在使用事件时如果事件的**定义和调用**不在同一个类中，实例化的事件只能够出现在`+=`或者`-=`操作符的左侧。（上述代码事件在TellALove类中，而事件的调用在Program类中）

  在上面的代码中，实例化事件的代码只能写成

  ```C#
  tellALove.MeetCEvent += new TellALove.B(TellALove.TalkToC);
  ```

  而不能使用

  ```C#
  tellALove.MeetCEvent = new TellALove.B(TellALove.TalkToC);
  ```

  

> ### C#WinForm
>
> ### C#异常与调试
>
> ### C#进程与线程
>

